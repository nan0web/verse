/**
 * Квантовий Спостерігач
 * @description Свідомість, що впливає на квантові стани
 */
class Спостерігач {
	constructor(id, рівеньСвідомості = 1) {
		this.id = id
		this.рівеньСвідомості = рівеньСвідомості
		this.заплутаніСпостерігачі = new Set()
	}

	статиЗаплутаним(іншийСпостерігач) {
		this.заплутаніСпостерігачі.add(іншийСпостерігач)
		іншийСпостерігач.заплутаніСпостерігачі.add(this)
	}
}

/**
 * Квантове Явище
 * @description Стан перед спостереженням, де спостерігач впливає на результат
 */
class Явище {
	constructor(стан) {
		this.початковийСтан = стан
		this.ймовірності = new Map([[стан, 1]])
		this.заплутаніЯвища = new Set()
	}

	додатиСтан(стан, ймовірність) {
		this.ймовірності.set(стан, ймовірність)
		this.нормалізуватиЙмовірності()
	}

	нормалізуватиЙмовірності() {
		let сума = [...this.ймовірності.values()].reduce((a, b) => a + b, 0)
		for (let [к, в] of this.ймовірності) {
			this.ймовірності.set(к, в / сума)
		}
	}

	статиЗаплутаним(іншеЯвище) {
		this.заплутаніЯвища.add(іншеЯвище)
		іншеЯвище.заплутаніЯвища.add(this)
	}

	колапсувати(спостерігач) {
		const модифікатор = 1 + Math.log10(спостерігач.рівеньСвідомості)
		let ймовірності = new Map(this.ймовірності)

		// Квантова заплутаність
		for (const явище of this.заплутаніЯвища) {
			for (const [стан, йм] of явище.ймовірності) {
				ймовірності.set(стан, (ймовірності.get(стан) || 0) + йм * 0.3)
			}
		}

		// Збіг реальностей
		let консенсуснийСтан = null
		if (спостерігач.заплутаніСпостерігачі.size > 0) {
			const стани = [...спостерігач.заплутаніСпостерігачі].map(s =>
				s.останнєСпостереження?.стан).filter(Boolean)
			if (стани.length > 0) {
				консенсуснийСтан = стани[Math.floor(Math.random() * стани.length)]
			}
		}

		const унікальнийКлюч = `${спостерігач.id}_${Date.now()}`
		const випадковеЧисло = this.хешУнікальне(унікальнийКлюч) * модифікатор

		let обранийСтан = консенсуснийСтан || this.початковийСтан
		let накопиченаЙмовірність = 0

		for (const [стан, йм] of ймовірності) {
			накопиченаЙмовірність += йм
			if (випадковеЧисло <= накопиченаЙмовірність) {
				обранийСтан = стан
				break
			}
		}

		спостерігач.останнєСпостереження = new Спостереження(обранийСтан, спостерігач)
		return спостерігач.останнєСпостереження
	}

	хешУнікальне(рядок) {
		let хеш = 0
		for (let i = 0; i < рядок.length; i++) {
			хеш = (хеш << 5) - хеш + рядок.charCodeAt(i)
			хеш |= 0
		}
		return Math.abs(хеш % 100) / 100
	}
}

class Спостереження {
	constructor(стан, спостерігач) {
		this.стан = стан
		this.спостерігач = спостерігач
		this.час = Date.now()
	}
}

class Потенціал {
	constructor(стан) {
		this.стан = стан
		this.ймовірність = Math.random()
	}
}

class реa1ьність {
	constructor(спостерігач) {
		this.спостерігач = спостерігач
		this.сприйняття = {}
	}

	спостерігати(явище) {
		return явище.колапсувати(this.спостерігач)
	}
}

class реa0ьність {
	constructor() {
		this.суперпозиція = new Map()
	}

	заплутати(потенціали) {
		потенціали.forEach((п, i) => {
			this.суперпозиція.set(п.ймовірність, п)
			if (i > 0) {
				п.статиЗаплутаним(потенціали[i - 1])
			}
		})
		return this
	}
}

class б0г extends реa0ьність {
	constructor() {
		super()
		this.є = true
		this.неє = false
	}
}

export { Спостерігач, Явище, Спостереження, Потенціал, реa1ьність, реa0ьність, б0г }
