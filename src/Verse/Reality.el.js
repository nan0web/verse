/**
 * Κβαντικός Παρατηρητής
 * @description Συνείδηση που καταρρέει την κυματοσυνάρτηση
 */
class Παρατηρητής {
	constructor(id, επίπεδοΣυνείδησης = 1) {
		this.id = id
		this.επίπεδοΣυνείδησης = επίπεδοΣυνείδησης
		this.εμπλεγμένοιΠαρατηρητές = new Set()
	}

	εμπλέκω(άλλοςΠαρατηρητής) {
		this.εμπλεγμένοιΠαρατηρητές.add(άλλοςΠαρατηρητής)
		άλλοςΠαρατηρητής.εμπλεγμένοιΠαρατηρητές.add(this)
	}
}
/**
 * Κβαντικό Φαινόμενο
 * @description Κατάσταση πριν την παρατήρηση
 */
class Φαινόμενο {
	constructor(κατάσταση) {
		this.αρχικήΚατάσταση = κατάσταση
		this.πιθανότητες = new Map([[κατάσταση, 1]])
		this.εμπλεγμέναΦαινόμενα = new Set()
	}

	προσθήκηΚατάστασης(κατάσταση, πιθανότητα) {
		this.πιθανότητες.set(κατάσταση, πιθανότητα)
		this.κανονικοποίησηΠιθανοτήτων()
	}

	κανονικοποίησηΠιθανοτήτων() {
		let άθροισμα = [...this.πιθανότητες.values()].reduce((a, b) => a + b, 0)
		for (let [κ, π] of this.πιθανότητες) {
			this.πιθανότητες.set(κ, π / άθροισμα)
		}
	}

	εμπλέκω(άλλοΦαινόμενο) {
		this.εμπλεγμέναΦαινόμενα.add(άλλοΦαινόμενο)
		άλλοΦαινόμενο.εμπλεγμέναΦαινόμενα.add(this)
	}

	καταρρέω(παρατηρητής) {
		const τροποποιητής = 1 + Math.log10(παρατηρητής.επίπεδοΣυνείδησης)
		let πιθανότητες = new Map(this.πιθανότητες)

		// Κβαντική εμπλοκή
		for (const φαινόμενο of this.εμπλεγμέναΦαινόμενα) {
			for (const [κατάσταση, πιθ] of φαινόμενο.πιθανότητες) {
				πιθανότητες.set(κατάσταση, (πιθανότητες.get(κατάσταση) || 0) + πιθ * 0.3)
			}
		}

		// Σύμπτωση πραγματικοτήτων
		let συναινετικήΚατάσταση = null
		if (παρατηρητής.εμπλεγμένοιΠαρατηρητές.size > 0) {
			const καταστάσεις = [...παρατηρητής.εμπλεγμένοιΠαρατηρητές].map(π =>
				π.τελευταίαΠαρατήρηση?.κατάσταση).filter(Boolean)
			if (καταστάσεις.length > 0) {
				συναινετικήΚατάσταση = καταστάσεις[Math.floor(Math.random() * καταστάσεις.length)]
			}
		}

		const μοναδικόΚλειδί = `${παρατηρητής.id}_${Date.now()}`
		const τυχαίοςΑριθμός = this.μοναδικόHash(μοναδικόΚλειδί) * τροποποιητής

		let επιλεγμένηΚατάσταση = συναινετικήΚατάσταση || this.αρχικήΚατάσταση
		let συσσωρευμένηΠιθανότητα = 0

		for (const [κατάσταση, πιθ] of πιθανότητες) {
			συσσωρευμένηΠιθανότητα += πιθ
			if (τυχαίοςΑριθμός <= συσσωρευμένηΠιθανότητα) {
				επιλεγμένηΚατάσταση = κατάσταση
				break
			}
		}

		παρατηρητής.τελευταίαΠαρατήρηση = new Παρατήρηση(επιλεγμένηΚατάσταση, παρατηρητής)
		return παρατηρητής.τελευταίαΠαρατήρηση
	}

	μοναδικόHash(str) {
		let hash = 0
		for (let i = 0; i < str.length; i++) {
			hash = (hash << 5) - hash + str.charCodeAt(i)
			hash |= 0
		}
		return Math.abs(hash % 100) / 100
	}
}
/**
 * Κβαντική Παρατήρηση
 * @description Καταρρευμένη κατάσταση από υπέρθεση
 */
class Παρατήρηση {
	constructor(κατάσταση, παρατηρητής) {
		this.κατάσταση = κατάσταση
		this.παρατηρητής = παρατηρητής
		this.χρονικήΣήμανση = Date.now()
	}
}

/**
 * Κβαντικό Δυναμικό
 * @description Πιθανή κβαντική κατάσταση
 */
class Δυναμικό {
	constructor(κατάσταση) {
		this.κατάσταση = κατάσταση
		this.πιθανότητα = Math.random()
	}
}

/**
 * πρα1τικότητα (υποκειμενική πραγματικότητα)
 */
class πρα1τικότητα {
	constructor(παρατηρητής) {
		this.παρατηρητής = παρατηρητής
		this.αντίληψη = {}
	}

	παρατηρώ(φαινόμενο) {
		return φαινόμενο.καταρρέω(this.παρατηρητής)
	}
}

/**
 * πρα0τικότητα (αντικειμενική πραγματικότητα)
 */
class πρα0τικότητα {
	constructor() {
		this.υπέρθεση = new Map()
	}

	εμπλέκω(δυναμικά) {
		δυναμικά.forEach((δ, i) => {
			this.υπέρθεση.set(δ.πιθανότητα, δ)
			if (i > 0) {
				δ.εμπλέκω(δυναμικά[i - 1])
			}
		})
		return this
	}
}

/**
 * Θεμελιώδης φύση της ύπαρξης
 */
class θ0ός extends πρα0τικότητα {
	constructor() {
		super()
		this.είναι = true
		this.δεν_είναι = false
	}
}

export { Παρατηρητής, Φαινόμενο, Παρατήρηση, Δυναμικό, πρα1τικότητα, πρα0τικότητα, θ0ός }
